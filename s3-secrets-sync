#!/usr/bin/env bash
#
# s3-secrets-sync - A tool for securely syncing environment variables to and from S3
#
# This script handles the encryption, decryption, upload, and download of environment
# variables to/from an S3 bucket, using pure bash and standard Unix utilities.

set -euo pipefail

# Version
VERSION=$(cat "$(dirname "$0")/VERSION" 2>/dev/null || echo "1.0.0")

# Default values
APP_ENV=""
SERVICE_TYPE="api"
ENV_FILE=".env"
ACTION=""
ENCRYPTION_KEY=""
S3_ENDPOINT="https://s3.amazonaws.com"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print error message and exit
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    exit 1
}

# Print success message
success() {
    echo -e "${GREEN}✓ $1${NC}"
}

# Print info message
info() {
    echo -e "${BLUE}ℹ $1${NC}"
}

# Print warning message
warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Show help
show_help() {
    cat << EOF
s3-secrets-sync v${VERSION} - Securely sync environment variables to and from S3

Usage: s3-secrets-sync <command> [options]

Commands:
  encrypt     Convert .env file to JSON and encrypt it
  decrypt     Decrypt JSON file to .env format
  upload      Upload encrypted file to S3
  download    Download encrypted file from S3
  sync        Encrypt and upload in one step
  pull        Download and decrypt in one step

Options:
  -e, --env ENV             Environment (development, staging, production)
  -s, --service TYPE        Service type (default: api)
  -f, --file PATH           Path to .env file (default: .env)
  -k, --key KEY             Encryption key (can also use ENV_ENCRYPTION_KEY env var)
  -b, --bucket NAME         S3 bucket name (can also use AWS_BUCKET_NAME env var)
  -r, --region REGION       AWS region (can also use AWS_REGION env var)
  --endpoint URL            S3 endpoint URL (default: https://s3.amazonaws.com)
  -h, --help                Show this help
  -v, --version             Show version information

Environment Variables:
  ENV_ENCRYPTION_KEY        Encryption key (alternative to -k flag)
  AWS_ACCESS_KEY_ID         AWS access key ID
  AWS_SECRET_ACCESS_KEY     AWS secret access key
  AWS_BUCKET_NAME           S3 bucket name (alternative to -b flag)
  AWS_REGION                AWS region (alternative to -r flag)

Examples:
  s3-secrets-sync encrypt -e production -s api -f .env -k mypassword
  s3-secrets-sync sync -e staging --service api --key mypassword
  s3-secrets-sync pull -e production -s api -k mypassword -b my-bucket
EOF
}

# Show version
show_version() {
    echo "s3-secrets-sync v${VERSION}"
}

# Check if required command exists and install if needed
check_command() {
    local cmd="$1"
    if ! command -v "$cmd" &> /dev/null; then
        warning "$cmd not found. Attempting to install..."
        
        # Detect OS
        if [ "$(uname)" == "Darwin" ]; then
            # macOS
            if command -v brew &> /dev/null; then
                info "Installing $cmd via Homebrew..."
                case "$cmd" in
                    aws) brew install awscli || error_exit "Failed to install AWS CLI. Please install it manually." ;;
                    jq) brew install jq || error_exit "Failed to install jq. Please install it manually." ;;
                    openssl) info "OpenSSL should be pre-installed on macOS. If not, try: brew install openssl" ;;
                    *) error_exit "$cmd installation not supported. Please install it manually." ;;
                esac
            elif [ "$cmd" = "aws" ] && command -v pip3 &> /dev/null; then
                info "Installing AWS CLI via pip3..."
                pip3 install --user awscli || error_exit "Failed to install AWS CLI. Please install it manually."
            else
                error_exit "Homebrew not found. Please install $cmd manually."
            fi
        elif [ "$(expr substr $(uname -s) 1 5)" == "Linux" ]; then
            # Linux
            if command -v apt-get &> /dev/null; then
                info "Installing $cmd via apt..."
                case "$cmd" in
                    aws) sudo apt-get update && sudo apt-get install -y awscli || error_exit "Failed to install AWS CLI. Please install it manually." ;;
                    jq) sudo apt-get update && sudo apt-get install -y jq || error_exit "Failed to install jq. Please install it manually." ;;
                    openssl) sudo apt-get update && sudo apt-get install -y openssl || error_exit "Failed to install OpenSSL. Please install it manually." ;;
                    *) error_exit "$cmd installation not supported. Please install it manually." ;;
                esac
            elif command -v yum &> /dev/null; then
                info "Installing $cmd via yum..."
                case "$cmd" in
                    aws) sudo yum install -y awscli || error_exit "Failed to install AWS CLI. Please install it manually." ;;
                    jq) sudo yum install -y jq || error_exit "Failed to install jq. Please install it manually." ;;
                    openssl) sudo yum install -y openssl || error_exit "Failed to install OpenSSL. Please install it manually." ;;
                    *) error_exit "$cmd installation not supported. Please install it manually." ;;
                esac
            elif [ "$cmd" = "aws" ] && command -v pip3 &> /dev/null; then
                info "Installing AWS CLI via pip3..."
                pip3 install --user awscli || error_exit "Failed to install AWS CLI. Please install it manually."
            else
                error_exit "Could not detect package manager. Please install $cmd manually."
            fi
        else
            error_exit "Unsupported OS. Please install $cmd manually."
        fi
        
        # Check if installation was successful
        if command -v "$cmd" &> /dev/null; then
            success "$cmd installed successfully."
        else
            error_exit "$cmd installation appeared to succeed but command still not found. Please install it manually."
        fi
    fi
}

# Check if required environment variables are set
check_env_vars() {
    local missing=0
    
    # Check for encryption operations
    if [[ "$ACTION" == "encrypt" || "$ACTION" == "decrypt" || "$ACTION" == "sync" || "$ACTION" == "pull" ]]; then
        if [[ -z "$ENCRYPTION_KEY" ]]; then
            error_exit "Encryption key not provided. Use -k flag or set ENV_ENCRYPTION_KEY environment variable."
        fi
    fi
    
    # Check for S3 operations
    if [[ "$ACTION" == "upload" || "$ACTION" == "download" || "$ACTION" == "sync" || "$ACTION" == "pull" ]]; then
        local aws_vars=("AWS_ACCESS_KEY_ID" "AWS_SECRET_ACCESS_KEY")
        
        for var in "${aws_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                warning "$var is not set"
                missing=1
            fi
        done
        
        if [[ -z "$AWS_BUCKET_NAME" ]]; then
            error_exit "S3 bucket name not provided. Use -b flag or set AWS_BUCKET_NAME environment variable."
        fi
        
        if [[ -z "$AWS_REGION" ]]; then
            warning "AWS_REGION is not set. Using default region."
        fi
    fi
    
    if [[ $missing -eq 1 ]]; then
        error_exit "Missing required AWS credentials."
    fi
}

# Convert .env file to JSON
env_to_json() {
    local env_file="$1"
    local json_file="$2"
    local temp_file="$(mktemp)"
    
    info "Converting $env_file to JSON..."
    
    # Check if env file exists
    if [[ ! -f "$env_file" ]]; then
        error_exit "Environment file $env_file not found."
    fi
    
    # Process .env file into JSON
    echo "{" > "$temp_file"
    grep -v '^#' "$env_file" | grep -v '^$' | while IFS= read -r line; do
        key="${line%%=*}"
        value="${line#*=}"
        # Remove quotes if present
        value="${value%\"}"
        value="${value#\"}"
        value="${value%\'}"
        value="${value#\'}"
        # Escape special characters for JSON
        value=$(echo "$value" | sed 's/\\/\\\\/g; s/"/\\"/g')
        echo "  \"$key\": \"$value\"," >> "$temp_file"
    done
    # Remove trailing comma and close JSON
    sed -i.bak '$ s/,$//' "$temp_file" && rm -f "${temp_file}.bak"
    echo "}" >> "$temp_file"
    
    # Move to final location
    mv "$temp_file" "$json_file"
    success "Converted $env_file to $json_file"
}

# Encrypt JSON file
encrypt_json() {
    local json_file="$1"
    local enc_file="$2"
    local key="$3"
    local temp_file="$(mktemp)"
    
    info "Encrypting $json_file..."
    
    # Check if json file exists
    if [[ ! -f "$json_file" ]]; then
        error_exit "JSON file $json_file not found."
    fi
    
    # Check dependencies
    check_command openssl
    
    # Generate random IV
    iv=$(openssl rand -hex 16)
    
    # Encrypt the data
    encrypted=$(openssl enc -aes-256-cbc -base64 -A -salt -in "$json_file" -pass "pass:$key" -iv "$iv" -K "$(echo -n "$key" | openssl dgst -sha256 -hex | sed 's/^.* //')" 2>/dev/null)
    
    # Create JSON structure with IV and encrypted data
    cat > "$temp_file" << EOF
{
  "iv": "$iv",
  "data": "$encrypted"
}
EOF
    
    # Move to final location
    mv "$temp_file" "$enc_file"
    success "Encrypted $json_file to $enc_file"
}

# Decrypt JSON file
decrypt_json() {
    local enc_file="$1"
    local json_file="$2"
    local key="$3"
    local temp_file="$(mktemp)"
    
    info "Decrypting $enc_file..."
    
    # Check if encrypted file exists
    if [[ ! -f "$enc_file" ]]; then
        error_exit "Encrypted file $enc_file not found."
    fi
    
    # Check dependencies
    check_command openssl
    check_command jq
    
    # Extract IV and data from JSON
    iv=$(jq -r .iv < "$enc_file")
    encrypted=$(jq -r .data < "$enc_file")
    
    # Decrypt the data
    echo "$encrypted" | openssl enc -aes-256-cbc -d -base64 -A -salt -pass "pass:$key" -iv "$iv" -K "$(echo -n "$key" | openssl dgst -sha256 -hex | sed 's/^.* //')" > "$temp_file" 2>/dev/null || error_exit "Decryption failed. Invalid key or corrupted data."
    
    # Move to final location
    mv "$temp_file" "$json_file"
    success "Decrypted $enc_file to $json_file"
}

# JSON to .env conversion
json_to_env() {
    local json_file="$1"
    local env_file="$2"
    local temp_file="$(mktemp)"
    
    info "Converting $json_file to .env format..."
    
    # Check if json file exists
    if [[ ! -f "$json_file" ]]; then
        error_exit "JSON file $json_file not found."
    fi
    
    # Check dependencies
    check_command jq
    
    # Convert JSON to .env
    jq -r 'to_entries | map("\(.key)=\(.value)") | .[]' < "$json_file" > "$temp_file"
    
    # Move to final location
    mv "$temp_file" "$env_file"
    success "Converted $json_file to $env_file"
}

# Upload file to S3
upload_to_s3() {
    local file_path="$1"
    local s3_key="$2"
    local bucket="$3"
    
    info "Uploading $file_path to s3://$bucket/$s3_key..."
    
    # Check if file exists
    if [[ ! -f "$file_path" ]]; then
        error_exit "File $file_path not found."
    fi
    
    # Check dependencies
    check_command aws
    
    # Upload to S3
    if aws --endpoint-url "$S3_ENDPOINT" s3 cp "$file_path" "s3://$bucket/$s3_key" --only-show-errors; then
        success "Upload successful."
    else
        error_exit "Upload failed."
    fi
}

# Download file from S3
download_from_s3() {
    local s3_key="$1"
    local file_path="$2"
    local bucket="$3"
    
    info "Downloading s3://$bucket/$s3_key to $file_path..."
    
    # Check dependencies
    check_command aws
    
    # Download from S3
    if aws --endpoint-url "$S3_ENDPOINT" s3 cp "s3://$bucket/$s3_key" "$file_path" --only-show-errors; then
        success "Download successful."
    else
        error_exit "Download failed. Make sure the file exists and you have proper permissions."
    fi
}

# Clean up temporary files
cleanup_files() {
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            info "Cleaning up $file..."
            rm -f "$file"
        fi
    done
}

# Parse command line arguments
parse_args() {
    # First positional argument is the action
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    ACTION="$1"
    shift
    
    case "$ACTION" in
        encrypt|decrypt|upload|download|sync|pull)
            # Valid action, continue
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        *)
            error_exit "Unknown command: $ACTION. Run with --help for usage information."
            ;;
    esac
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--env)
                APP_ENV="$2"
                shift 2
                ;;
            -s|--service)
                SERVICE_TYPE="$2"
                shift 2
                ;;
            -f|--file)
                ENV_FILE="$2"
                shift 2
                ;;
            -k|--key)
                ENCRYPTION_KEY="$2"
                shift 2
                ;;
            -b|--bucket)
                AWS_BUCKET_NAME="$2"
                shift 2
                ;;
            -r|--region)
                AWS_REGION="$2"
                shift 2
                ;;
            --endpoint)
                S3_ENDPOINT="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1. Run with --help for usage information."
                ;;
        esac
    done
    
    # Load encryption key from environment if not provided via command line
    if [[ -z "$ENCRYPTION_KEY" ]]; then
        ENCRYPTION_KEY="${ENV_ENCRYPTION_KEY:-}"
    fi
    
    # Make sure environment is provided
    if [[ -z "$APP_ENV" ]]; then
        error_exit "Environment (-e) is required."
    fi
}

# Main execution
main() {
    # Parse command line arguments
    parse_args "$@"
    
    # Define file paths
    local base_name="palanck-env-${APP_ENV}-${SERVICE_TYPE}"
    local json_file="${base_name}.json"
    local enc_file="${json_file}.enc"
    local s3_key="secrets/${enc_file}"
    
    # Check required environment variables
    check_env_vars
    
    # Execute requested action
    case "$ACTION" in
        encrypt)
            env_to_json "$ENV_FILE" "$json_file"
            encrypt_json "$json_file" "$enc_file" "$ENCRYPTION_KEY"
            cleanup_files "$json_file"
            ;;
        decrypt)
            decrypt_json "$enc_file" "$json_file" "$ENCRYPTION_KEY"
            json_to_env "$json_file" "$ENV_FILE"
            cleanup_files "$json_file"
            ;;
        upload)
            upload_to_s3 "$enc_file" "$s3_key" "$AWS_BUCKET_NAME"
            ;;
        download)
            download_from_s3 "$s3_key" "$enc_file" "$AWS_BUCKET_NAME"
            ;;
        sync)
            env_to_json "$ENV_FILE" "$json_file"
            encrypt_json "$json_file" "$enc_file" "$ENCRYPTION_KEY"
            upload_to_s3 "$enc_file" "$s3_key" "$AWS_BUCKET_NAME"
            cleanup_files "$json_file" "$enc_file"
            ;;
        pull)
            download_from_s3 "$s3_key" "$enc_file" "$AWS_BUCKET_NAME"
            decrypt_json "$enc_file" "$json_file" "$ENCRYPTION_KEY"
            json_to_env "$json_file" "$ENV_FILE"
            cleanup_files "$enc_file" "$json_file"
            ;;
    esac
    
    success "Operation completed successfully."
}

main "$@"
